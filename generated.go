// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package fsgraph

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	strconv "strconv"
	sync "sync"

	graphql "github.com/99designs/gqlgen/graphql"
	introspection "github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser"
	ast "github.com/vektah/gqlparser/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Dir() DirResolver
	FileResult() FileResultResolver
	Internal_OtherFile() Internal_OtherFileResolver
	Mutation() MutationResolver
	Query() QueryResolver
	RegularFile() RegularFileResolver
}

type DirectiveRoot struct {
	ScalarInfo func(ctx context.Context, obj interface{}, next graphql.Resolver, baseType string) (res interface{}, err error)
}

type ComplexityRoot struct {
	Dir struct {
		Id       func(childComplexity int) int
		Name     func(childComplexity int) int
		Path     func(childComplexity int) int
		Size     func(childComplexity int) int
		Mode     func(childComplexity int) int
		ModTime  func(childComplexity int) int
		Parent   func(childComplexity int) int
		Children func(childComplexity int, first int) int
		File     func(childComplexity int, path string) int
	}

	FileContents struct {
		Data     func(childComplexity int) int
		Next     func(childComplexity int) int
		Encoding func(childComplexity int) int
		Warning  func(childComplexity int) int
	}

	FileMode struct {
		Type   func(childComplexity int) int
		Perm   func(childComplexity int) int
		Sticky func(childComplexity int) int
	}

	FileResult struct {
		S       func(childComplexity int) int
		Warning func(childComplexity int) int
		File    func(childComplexity int) int
	}

	InternalOtherFile struct {
		Id      func(childComplexity int) int
		Name    func(childComplexity int) int
		Path    func(childComplexity int) int
		Size    func(childComplexity int) int
		Mode    func(childComplexity int) int
		ModTime func(childComplexity int) int
		Parent  func(childComplexity int) int
	}

	Mutation struct {
		Remove   func(childComplexity int, path string) int
		Rename   func(childComplexity int, path string, newName string) int
		Chmod    func(childComplexity int, path string, mode int) int
		Write    func(childComplexity int, path string, contents string, open []FileOpen, encoding Encoding) int
		Mkdir    func(childComplexity int, path string) int
		MkdirAll func(childComplexity int, path string) int
	}

	Okresult struct {
		S       func(childComplexity int) int
		Warning func(childComplexity int) int
	}

	Query struct {
		Root func(childComplexity int) int
		Cd   func(childComplexity int, path string) int
		File func(childComplexity int, path string) int
	}

	RegularFile struct {
		Id       func(childComplexity int) int
		Name     func(childComplexity int) int
		Path     func(childComplexity int) int
		Size     func(childComplexity int) int
		Mode     func(childComplexity int) int
		ModTime  func(childComplexity int) int
		Parent   func(childComplexity int) int
		Contents func(childComplexity int, encoding Encoding, maxReadBytes Int64, seek Int64) int
	}
}

type DirResolver interface {
	Parent(ctx context.Context, obj *Dir) (File, error)
	Children(ctx context.Context, obj *Dir, first int) ([]File, error)
	File(ctx context.Context, obj *Dir, path string) (File, error)
}
type FileResultResolver interface {
	File(ctx context.Context, obj *FileResult) (File, error)
}
type Internal_OtherFileResolver interface {
	Parent(ctx context.Context, obj *Internal_OtherFile) (File, error)
}
type MutationResolver interface {
	Remove(ctx context.Context, path string) (OKResult, error)
	Rename(ctx context.Context, path string, newName string) (FileResult, error)
	Chmod(ctx context.Context, path string, mode int) (FileResult, error)
	Write(ctx context.Context, path string, contents string, open []FileOpen, encoding Encoding) (FileResult, error)
	Mkdir(ctx context.Context, path string) (FileResult, error)
	MkdirAll(ctx context.Context, path string) (FileResult, error)
}
type QueryResolver interface {
	Root(ctx context.Context) (Dir, error)
	Cd(ctx context.Context, path string) (*Dir, error)
	File(ctx context.Context, path string) (File, error)
}
type RegularFileResolver interface {
	Parent(ctx context.Context, obj *RegularFile) (File, error)
	Contents(ctx context.Context, obj *RegularFile, encoding Encoding, maxReadBytes Int64, seek Int64) (FileContents, error)
}

func field_Dir_children_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["first"]; ok {
		var err error
		arg0, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	return args, nil

}

func field_Dir_file_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil

}

func field_Mutation_remove_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil

}

func field_Mutation_rename_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["newName"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["newName"] = arg1
	return args, nil

}

func field_Mutation_chmod_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["mode"]; ok {
		var err error
		arg1, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["mode"] = arg1
	return args, nil

}

func field_Mutation_write_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["contents"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["contents"] = arg1
	var arg2 []FileOpen
	if tmp, ok := rawArgs["open"]; ok {
		var err error
		var rawIf1 []interface{}
		if tmp != nil {
			if tmp1, ok := tmp.([]interface{}); ok {
				rawIf1 = tmp1
			} else {
				rawIf1 = []interface{}{tmp}
			}
		}
		arg2 = make([]FileOpen, len(rawIf1))
		for idx1 := range rawIf1 {
			err = (&arg2[idx1]).UnmarshalGQL(rawIf1[idx1])
		}
		if err != nil {
			return nil, err
		}
	}
	args["open"] = arg2
	var arg3 Encoding
	if tmp, ok := rawArgs["encoding"]; ok {
		var err error
		err = (&arg3).UnmarshalGQL(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["encoding"] = arg3
	return args, nil

}

func field_Mutation_mkdir_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil

}

func field_Mutation_mkdirAll_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil

}

func field_Query_cd_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil

}

func field_Query_file_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["path"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["path"] = arg0
	return args, nil

}

func field_Query___type_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field_RegularFile_contents_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 Encoding
	if tmp, ok := rawArgs["encoding"]; ok {
		var err error
		err = (&arg0).UnmarshalGQL(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["encoding"] = arg0
	var arg1 Int64
	if tmp, ok := rawArgs["maxReadBytes"]; ok {
		var err error
		err = (&arg1).UnmarshalGQL(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["maxReadBytes"] = arg1
	var arg2 Int64
	if tmp, ok := rawArgs["seek"]; ok {
		var err error
		err = (&arg2).UnmarshalGQL(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["seek"] = arg2
	return args, nil

}

func field___Type_fields_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

func field___Type_enumValues_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

func dir_scalarInfo_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["baseType"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["baseType"] = arg0
	return args, nil

}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	switch typeName + "." + field {

	case "Dir.id":
		if e.complexity.Dir.Id == nil {
			break
		}

		return e.complexity.Dir.Id(childComplexity), true

	case "Dir.name":
		if e.complexity.Dir.Name == nil {
			break
		}

		return e.complexity.Dir.Name(childComplexity), true

	case "Dir.path":
		if e.complexity.Dir.Path == nil {
			break
		}

		return e.complexity.Dir.Path(childComplexity), true

	case "Dir.size":
		if e.complexity.Dir.Size == nil {
			break
		}

		return e.complexity.Dir.Size(childComplexity), true

	case "Dir.mode":
		if e.complexity.Dir.Mode == nil {
			break
		}

		return e.complexity.Dir.Mode(childComplexity), true

	case "Dir.modTime":
		if e.complexity.Dir.ModTime == nil {
			break
		}

		return e.complexity.Dir.ModTime(childComplexity), true

	case "Dir.parent":
		if e.complexity.Dir.Parent == nil {
			break
		}

		return e.complexity.Dir.Parent(childComplexity), true

	case "Dir.children":
		if e.complexity.Dir.Children == nil {
			break
		}

		args, err := field_Dir_children_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Dir.Children(childComplexity, args["first"].(int)), true

	case "Dir.file":
		if e.complexity.Dir.File == nil {
			break
		}

		args, err := field_Dir_file_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Dir.File(childComplexity, args["path"].(string)), true

	case "FileContents.data":
		if e.complexity.FileContents.Data == nil {
			break
		}

		return e.complexity.FileContents.Data(childComplexity), true

	case "FileContents.next":
		if e.complexity.FileContents.Next == nil {
			break
		}

		return e.complexity.FileContents.Next(childComplexity), true

	case "FileContents.encoding":
		if e.complexity.FileContents.Encoding == nil {
			break
		}

		return e.complexity.FileContents.Encoding(childComplexity), true

	case "FileContents.warning":
		if e.complexity.FileContents.Warning == nil {
			break
		}

		return e.complexity.FileContents.Warning(childComplexity), true

	case "FileMode.type":
		if e.complexity.FileMode.Type == nil {
			break
		}

		return e.complexity.FileMode.Type(childComplexity), true

	case "FileMode.perm":
		if e.complexity.FileMode.Perm == nil {
			break
		}

		return e.complexity.FileMode.Perm(childComplexity), true

	case "FileMode.sticky":
		if e.complexity.FileMode.Sticky == nil {
			break
		}

		return e.complexity.FileMode.Sticky(childComplexity), true

	case "FileResult.s":
		if e.complexity.FileResult.S == nil {
			break
		}

		return e.complexity.FileResult.S(childComplexity), true

	case "FileResult.warning":
		if e.complexity.FileResult.Warning == nil {
			break
		}

		return e.complexity.FileResult.Warning(childComplexity), true

	case "FileResult.file":
		if e.complexity.FileResult.File == nil {
			break
		}

		return e.complexity.FileResult.File(childComplexity), true

	case "Internal_OtherFile.id":
		if e.complexity.InternalOtherFile.Id == nil {
			break
		}

		return e.complexity.InternalOtherFile.Id(childComplexity), true

	case "Internal_OtherFile.name":
		if e.complexity.InternalOtherFile.Name == nil {
			break
		}

		return e.complexity.InternalOtherFile.Name(childComplexity), true

	case "Internal_OtherFile.path":
		if e.complexity.InternalOtherFile.Path == nil {
			break
		}

		return e.complexity.InternalOtherFile.Path(childComplexity), true

	case "Internal_OtherFile.size":
		if e.complexity.InternalOtherFile.Size == nil {
			break
		}

		return e.complexity.InternalOtherFile.Size(childComplexity), true

	case "Internal_OtherFile.mode":
		if e.complexity.InternalOtherFile.Mode == nil {
			break
		}

		return e.complexity.InternalOtherFile.Mode(childComplexity), true

	case "Internal_OtherFile.modTime":
		if e.complexity.InternalOtherFile.ModTime == nil {
			break
		}

		return e.complexity.InternalOtherFile.ModTime(childComplexity), true

	case "Internal_OtherFile.parent":
		if e.complexity.InternalOtherFile.Parent == nil {
			break
		}

		return e.complexity.InternalOtherFile.Parent(childComplexity), true

	case "Mutation.remove":
		if e.complexity.Mutation.Remove == nil {
			break
		}

		args, err := field_Mutation_remove_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Remove(childComplexity, args["path"].(string)), true

	case "Mutation.rename":
		if e.complexity.Mutation.Rename == nil {
			break
		}

		args, err := field_Mutation_rename_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Rename(childComplexity, args["path"].(string), args["newName"].(string)), true

	case "Mutation.chmod":
		if e.complexity.Mutation.Chmod == nil {
			break
		}

		args, err := field_Mutation_chmod_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Chmod(childComplexity, args["path"].(string), args["mode"].(int)), true

	case "Mutation.write":
		if e.complexity.Mutation.Write == nil {
			break
		}

		args, err := field_Mutation_write_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Write(childComplexity, args["path"].(string), args["contents"].(string), args["open"].([]FileOpen), args["encoding"].(Encoding)), true

	case "Mutation.mkdir":
		if e.complexity.Mutation.Mkdir == nil {
			break
		}

		args, err := field_Mutation_mkdir_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Mkdir(childComplexity, args["path"].(string)), true

	case "Mutation.mkdirAll":
		if e.complexity.Mutation.MkdirAll == nil {
			break
		}

		args, err := field_Mutation_mkdirAll_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MkdirAll(childComplexity, args["path"].(string)), true

	case "OKResult.s":
		if e.complexity.Okresult.S == nil {
			break
		}

		return e.complexity.Okresult.S(childComplexity), true

	case "OKResult.warning":
		if e.complexity.Okresult.Warning == nil {
			break
		}

		return e.complexity.Okresult.Warning(childComplexity), true

	case "Query.root":
		if e.complexity.Query.Root == nil {
			break
		}

		return e.complexity.Query.Root(childComplexity), true

	case "Query.cd":
		if e.complexity.Query.Cd == nil {
			break
		}

		args, err := field_Query_cd_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Cd(childComplexity, args["path"].(string)), true

	case "Query.file":
		if e.complexity.Query.File == nil {
			break
		}

		args, err := field_Query_file_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.File(childComplexity, args["path"].(string)), true

	case "RegularFile.id":
		if e.complexity.RegularFile.Id == nil {
			break
		}

		return e.complexity.RegularFile.Id(childComplexity), true

	case "RegularFile.name":
		if e.complexity.RegularFile.Name == nil {
			break
		}

		return e.complexity.RegularFile.Name(childComplexity), true

	case "RegularFile.path":
		if e.complexity.RegularFile.Path == nil {
			break
		}

		return e.complexity.RegularFile.Path(childComplexity), true

	case "RegularFile.size":
		if e.complexity.RegularFile.Size == nil {
			break
		}

		return e.complexity.RegularFile.Size(childComplexity), true

	case "RegularFile.mode":
		if e.complexity.RegularFile.Mode == nil {
			break
		}

		return e.complexity.RegularFile.Mode(childComplexity), true

	case "RegularFile.modTime":
		if e.complexity.RegularFile.ModTime == nil {
			break
		}

		return e.complexity.RegularFile.ModTime(childComplexity), true

	case "RegularFile.parent":
		if e.complexity.RegularFile.Parent == nil {
			break
		}

		return e.complexity.RegularFile.Parent(childComplexity), true

	case "RegularFile.contents":
		if e.complexity.RegularFile.Contents == nil {
			break
		}

		args, err := field_RegularFile_contents_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RegularFile.Contents(childComplexity, args["encoding"].(Encoding), args["maxReadBytes"].(Int64), args["seek"].(Int64)), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

var dirImplementors = []string{"Dir", "File"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Dir(ctx context.Context, sel ast.SelectionSet, obj *Dir) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, dirImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Dir")
		case "id":
			out.Values[i] = ec._Dir_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Dir_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "path":
			out.Values[i] = ec._Dir_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "size":
			out.Values[i] = ec._Dir_size(ctx, field, obj)
		case "mode":
			out.Values[i] = ec._Dir_mode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "modTime":
			out.Values[i] = ec._Dir_modTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "parent":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Dir_parent(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "children":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Dir_children(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "file":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Dir_file(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Dir_id(ctx context.Context, field graphql.CollectedField, obj *Dir) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "Dir",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Dir_name(ctx context.Context, field graphql.CollectedField, obj *Dir) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "Dir",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Dir_path(ctx context.Context, field graphql.CollectedField, obj *Dir) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "Dir",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Dir_size(ctx context.Context, field graphql.CollectedField, obj *Dir) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "Dir",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Int64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Dir_mode(ctx context.Context, field graphql.CollectedField, obj *Dir) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "Dir",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mode(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FileMode)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._FileMode(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Dir_modTime(ctx context.Context, field graphql.CollectedField, obj *Dir) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "Dir",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModTime(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Dir_parent(ctx context.Context, field graphql.CollectedField, obj *Dir) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "Dir",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Dir().Parent(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(File)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._File(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Dir_children(ctx context.Context, field graphql.CollectedField, obj *Dir) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Dir_children_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Dir",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Dir().Children(rctx, obj, args["first"].(int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]File)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._File(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Dir_file(ctx context.Context, field graphql.CollectedField, obj *Dir) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Dir_file_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Dir",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Dir().File(rctx, obj, args["path"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(File)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._File(ctx, field.Selections, &res)
}

var fileContentsImplementors = []string{"FileContents"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FileContents(ctx context.Context, sel ast.SelectionSet, obj *FileContents) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, fileContentsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileContents")
		case "data":
			out.Values[i] = ec._FileContents_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "next":
			out.Values[i] = ec._FileContents_next(ctx, field, obj)
		case "encoding":
			out.Values[i] = ec._FileContents_encoding(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "warning":
			out.Values[i] = ec._FileContents_warning(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _FileContents_data(ctx context.Context, field graphql.CollectedField, obj *FileContents) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "FileContents",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _FileContents_next(ctx context.Context, field graphql.CollectedField, obj *FileContents) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "FileContents",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Next, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Int64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return *res
}

// nolint: vetshadow
func (ec *executionContext) _FileContents_encoding(ctx context.Context, field graphql.CollectedField, obj *FileContents) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "FileContents",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Encoding, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Encoding)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _FileContents_warning(ctx context.Context, field graphql.CollectedField, obj *FileContents) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "FileContents",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Warning, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var fileModeImplementors = []string{"FileMode"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FileMode(ctx context.Context, sel ast.SelectionSet, obj *FileMode) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, fileModeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileMode")
		case "type":
			out.Values[i] = ec._FileMode_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "perm":
			out.Values[i] = ec._FileMode_perm(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "sticky":
			out.Values[i] = ec._FileMode_sticky(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _FileMode_type(ctx context.Context, field graphql.CollectedField, obj *FileMode) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "FileMode",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FileType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _FileMode_perm(ctx context.Context, field graphql.CollectedField, obj *FileMode) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "FileMode",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Perm, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _FileMode_sticky(ctx context.Context, field graphql.CollectedField, obj *FileMode) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "FileMode",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sticky, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

var fileResultImplementors = []string{"FileResult", "Result"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FileResult(ctx context.Context, sel ast.SelectionSet, obj *FileResult) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, fileResultImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileResult")
		case "s":
			out.Values[i] = ec._FileResult_s(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "warning":
			out.Values[i] = ec._FileResult_warning(ctx, field, obj)
		case "file":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._FileResult_file(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _FileResult_s(ctx context.Context, field graphql.CollectedField, obj *FileResult) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "FileResult",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.S, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _FileResult_warning(ctx context.Context, field graphql.CollectedField, obj *FileResult) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "FileResult",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Warning, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _FileResult_file(ctx context.Context, field graphql.CollectedField, obj *FileResult) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "FileResult",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FileResult().File(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(File)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._File(ctx, field.Selections, &res)
}

var internal_OtherFileImplementors = []string{"Internal_OtherFile", "File"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Internal_OtherFile(ctx context.Context, sel ast.SelectionSet, obj *Internal_OtherFile) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, internal_OtherFileImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Internal_OtherFile")
		case "id":
			out.Values[i] = ec._Internal_OtherFile_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Internal_OtherFile_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "path":
			out.Values[i] = ec._Internal_OtherFile_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "size":
			out.Values[i] = ec._Internal_OtherFile_size(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mode":
			out.Values[i] = ec._Internal_OtherFile_mode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "modTime":
			out.Values[i] = ec._Internal_OtherFile_modTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "parent":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Internal_OtherFile_parent(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Internal_OtherFile_id(ctx context.Context, field graphql.CollectedField, obj *Internal_OtherFile) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "Internal_OtherFile",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Internal_OtherFile_name(ctx context.Context, field graphql.CollectedField, obj *Internal_OtherFile) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "Internal_OtherFile",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Internal_OtherFile_path(ctx context.Context, field graphql.CollectedField, obj *Internal_OtherFile) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "Internal_OtherFile",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Internal_OtherFile_size(ctx context.Context, field graphql.CollectedField, obj *Internal_OtherFile) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "Internal_OtherFile",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Int64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _Internal_OtherFile_mode(ctx context.Context, field graphql.CollectedField, obj *Internal_OtherFile) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "Internal_OtherFile",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mode(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FileMode)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._FileMode(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Internal_OtherFile_modTime(ctx context.Context, field graphql.CollectedField, obj *Internal_OtherFile) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "Internal_OtherFile",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModTime(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Internal_OtherFile_parent(ctx context.Context, field graphql.CollectedField, obj *Internal_OtherFile) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "Internal_OtherFile",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Internal_OtherFile().Parent(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(File)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._File(ctx, field.Selections, &res)
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "remove":
			out.Values[i] = ec._Mutation_remove(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rename":
			out.Values[i] = ec._Mutation_rename(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "chmod":
			out.Values[i] = ec._Mutation_chmod(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "write":
			out.Values[i] = ec._Mutation_write(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mkdir":
			out.Values[i] = ec._Mutation_mkdir(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mkdirAll":
			out.Values[i] = ec._Mutation_mkdirAll(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_remove(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_remove_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Remove(rctx, args["path"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(OKResult)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._OKResult(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_rename(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_rename_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Rename(rctx, args["path"].(string), args["newName"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FileResult)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._FileResult(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_chmod(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_chmod_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Chmod(rctx, args["path"].(string), args["mode"].(int))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FileResult)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._FileResult(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_write(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_write_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Write(rctx, args["path"].(string), args["contents"].(string), args["open"].([]FileOpen), args["encoding"].(Encoding))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FileResult)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._FileResult(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_mkdir(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_mkdir_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Mkdir(rctx, args["path"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FileResult)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._FileResult(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_mkdirAll(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_mkdirAll_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().MkdirAll(rctx, args["path"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FileResult)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._FileResult(ctx, field.Selections, &res)
}

var oKResultImplementors = []string{"OKResult", "Result"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _OKResult(ctx context.Context, sel ast.SelectionSet, obj *OKResult) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, oKResultImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OKResult")
		case "s":
			out.Values[i] = ec._OKResult_s(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "warning":
			out.Values[i] = ec._OKResult_warning(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _OKResult_s(ctx context.Context, field graphql.CollectedField, obj *OKResult) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "OKResult",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.S, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _OKResult_warning(ctx context.Context, field graphql.CollectedField, obj *OKResult) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "OKResult",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Warning, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "root":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_root(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "cd":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_cd(ctx, field)
				wg.Done()
			}(i, field)
		case "file":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_file(ctx, field)
				wg.Done()
			}(i, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Query_root(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Root(rctx)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Dir)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._Dir(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_cd(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_cd_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Cd(rctx, args["path"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Dir)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Dir(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_file(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_file_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().File(rctx, args["path"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(File)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._File(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query___type_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Schema(ctx, field.Selections, res)
}

var regularFileImplementors = []string{"RegularFile", "File"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RegularFile(ctx context.Context, sel ast.SelectionSet, obj *RegularFile) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, regularFileImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RegularFile")
		case "id":
			out.Values[i] = ec._RegularFile_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._RegularFile_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "path":
			out.Values[i] = ec._RegularFile_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "size":
			out.Values[i] = ec._RegularFile_size(ctx, field, obj)
		case "mode":
			out.Values[i] = ec._RegularFile_mode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "modTime":
			out.Values[i] = ec._RegularFile_modTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "parent":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._RegularFile_parent(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "contents":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._RegularFile_contents(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _RegularFile_id(ctx context.Context, field graphql.CollectedField, obj *RegularFile) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "RegularFile",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _RegularFile_name(ctx context.Context, field graphql.CollectedField, obj *RegularFile) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "RegularFile",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _RegularFile_path(ctx context.Context, field graphql.CollectedField, obj *RegularFile) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "RegularFile",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _RegularFile_size(ctx context.Context, field graphql.CollectedField, obj *RegularFile) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "RegularFile",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(Int64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return res
}

// nolint: vetshadow
func (ec *executionContext) _RegularFile_mode(ctx context.Context, field graphql.CollectedField, obj *RegularFile) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "RegularFile",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mode(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FileMode)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._FileMode(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _RegularFile_modTime(ctx context.Context, field graphql.CollectedField, obj *RegularFile) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "RegularFile",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModTime(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _RegularFile_parent(ctx context.Context, field graphql.CollectedField, obj *RegularFile) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "RegularFile",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RegularFile().Parent(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(File)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._File(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _RegularFile_contents(ctx context.Context, field graphql.CollectedField, obj *RegularFile) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_RegularFile_contents_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "RegularFile",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RegularFile().Contents(rctx, obj, args["encoding"].(Encoding), args["maxReadBytes"].(Int64), args["seek"].(Int64))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FileContents)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._FileContents(ctx, field.Selections, &res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __DirectiveImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __EnumValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __FieldImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __InputValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __SchemaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Directive(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __TypeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_fields_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Field(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_enumValues_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___EnumValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer ec.Tracer.EndFieldExecution(ctx)
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) _File(ctx context.Context, sel ast.SelectionSet, obj *File) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case RegularFile:
		return ec._RegularFile(ctx, sel, &obj)
	case *RegularFile:
		return ec._RegularFile(ctx, sel, obj)
	case Dir:
		return ec._Dir(ctx, sel, &obj)
	case *Dir:
		return ec._Dir(ctx, sel, obj)
	case Internal_OtherFile:
		return ec._Internal_OtherFile(ctx, sel, &obj)
	case *Internal_OtherFile:
		return ec._Internal_OtherFile(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Result(ctx context.Context, sel ast.SelectionSet, obj *Result) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case OKResult:
		return ec._OKResult(ctx, sel, &obj)
	case *OKResult:
		return ec._OKResult(ctx, sel, obj)
	case FileResult:
		return ec._FileResult(ctx, sel, &obj)
	case *FileResult:
		return ec._FileResult(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) FieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) (ret interface{}) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	rctx := graphql.GetResolverContext(ctx)
	for _, d := range rctx.Field.Definition.Directives {
		switch d.Name {
		case "scalarInfo":
			if ec.directives.ScalarInfo != nil {
				rawArgs := d.ArgumentMap(ec.Variables)
				args, err := dir_scalarInfo_args(rawArgs)
				if err != nil {
					ec.Error(ctx, err)
					return nil
				}
				n := next
				next = func(ctx context.Context) (interface{}, error) {
					return ec.directives.ScalarInfo(ctx, obj, n, args["baseType"].(string))
				}
			}
		}
	}
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name])
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema.graphql", Input: `directive @scalarInfo(
    baseType: String!
) on SCALAR

"a 64-bit integer"
scalar Int64 @scalarInfo(baseType: "Int")

enum FileType {
    regular
    dir
    symlink
    namedPipe
    socket
    device
    charDevice
    irregular
}

"a representation of the file's mode"
type FileMode {
    "the type of file"
    type: FileType!
    "permission bits"
    perm: Int!
    "whether or not the sticky bit is set"
    sticky: Boolean!
}

"a generic file"
interface File {
    "file ID"
    id: ID!
    "the file's name, without path"
    name: String!
    "the full path to the file"
    path: String!
    "the size of the file, in bytes"
    size: Int64
    "the file mode"
    mode: FileMode!
    "file modification time"
    modTime: String!
    "the parent directory of this file, or null if at the root directory"
    parent: File
}

"file contents (read) or write encoding"
enum Encoding {
    auto # only valid as input to RegularFile.contents
    utf8
    base64
}

"the contents of a file"
type FileContents {
    "the file's data contents"
    data: String!
    "the position of the file after the read if there is more data to read, to be used with seek"
    next: Int64
    "the encoding of data"
    encoding: Encoding!
    "set to a warning if there was data loss"
    warning: String
}

type RegularFile implements File {
    id: ID!
    name: String!
    path: String!
    size: Int64
    mode: FileMode!
    modTime: String!
    parent: File
    # maxReadBytes is the max bytes to return, default (-1) for unlimited.
    # The implementation may enforce a hard cap on the bytes read, requiring paging with next/seek.
    # Negative seek means don't seek.
    "the contents of this file"
    contents(encoding: Encoding! = auto, maxReadBytes: Int64! = -1, seek: Int64! = -1): FileContents!
}

type Dir implements File {
    id: ID!
    name: String!
    path: String!
    size: Int64
    mode: FileMode!
    modTime: String!
    parent: File
    # first is max children to return, default (-1) for unlimited.
    # The children are in no particular order.
    "this directory's nested (child) files"
    children(first: Int! = -1): [File!]!
    # escaping this parent dir is not allowed.
    "returns the specified nested file, or null if it doesn't exist"
    file(path: String!): File
}

# do not reference Internal_OtherFile; the other file types may be moved to new types.
"do not reference this type or depend on it in any way"
type Internal_OtherFile implements File {
    id: ID!
    name: String!
    path: String!
    size: Int64!
    mode: FileMode!
    modTime: String!
    parent: File
}

"a generic result of an operation"
interface Result {
    "a string describing the operation"
    s: String!
    "any warning messages, or null"
    warning: String
}

type OKResult implements Result {
    s: String!
    warning: String
}

"the result of a file operation"
type FileResult implements Result {
    s: String!
    warning: String
    "the target file"
    file: File!
}

type Query {
    "get the root dir"
    root: Dir!
    # Returns the specified dir. There is no concept of a current/working directory.
    # If the dir doesn't exist, null is returned.
    "returns the specified dir, or null if it doesn't exist"
    cd(path: String!): Dir
    # essentially a shortcut for root.file(path)
    "returns the specified nested file, or null if it doesn't exist"
    file(path: String!): File
}

"specifies how a file is to be opened"
enum FileOpen {
    "create file if it doesn't exist"
    create
    "file must not exist"
    new
    "truncate the file if it exists"
    truncate
    "writes will be appended to the end of the file"
    append
}

type Mutation {
    "remove the specified file; if a directory, it must be empty"
    remove(path: String!): OKResult!
    "rename a file"
    rename(path: String!, newName: String!): FileResult!
    "change a file's mode (permission bits)"
    chmod(path: String!, mode: Int!): FileResult!
    "write to the specified file"
    write(path: String!, contents: String!, open: [FileOpen!]! = [create, truncate], encoding: Encoding! = utf8): FileResult!
    "make a single dir"
    mkdir(path: String!): FileResult!
    "make entire dir path, attempts to create any missing dirs"
    mkdirAll(path: String!): FileResult!
}
`},
)
